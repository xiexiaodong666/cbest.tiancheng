<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.welfare.persist.mapper.AccountCustomizeMapper">
  <sql id="tableName">
    account
  </sql>

  <sql id="baseColumn">
    a.id,a.account_name,a.account_code,a.account_type_code,a.mer_code,a.store_code,a.account_status,a.staff_status,
        a.binding,a.create_user,a.create_time,a.update_user,a.update_time,a.account_balance,a.version,a.phone,a.max_quota,
        a.surplus_quota,a.change_event_id,a.remark,a.deleted
  </sql>

  <resultMap type="com.welfare.persist.entity.Account" id="accountMap">
    <id property="id" column="id"/>
    <result property="accountName" column="account_name"/>
    <result property="accountCode" column="account_code"/>
    <result property="accountTypeCode" column="account_type_code"/>
    <result property="merCode" column="mer_code"/>
    <result property="storeCode" column="store_code"/>
    <result property="accountStatus" column="account_status"/>
    <result property="staffStatus" column="staff_status"/>
    <result property="binding" column="binding"/>
    <result property="accountBalance" column="account_balance"/>
    <result property="phone" column="phone"/>
    <result property="maxQuota" column="max_quota"/>
    <result property="surplusQuota" column="surplus_quota"/>
    <result property="remark" column="remark"/>
    <result property="createUser" column="create_user"/>
    <result property="createTime" column="create_time"/>
    <result property="updateUser" column="update_user"/>
    <result property="updateTime" column="update_time"/>
    <result property="deleted" column="deleted"/>
    <result property="version" column="version"/>
    <result property="changeEventId" column="change_event_id"/>
  </resultMap>

  <select id ="getUpdateAccountByMerCode" resultMap="accountMap">
    select
    DISTINCT(a.id) as bsId,
    <include refid="baseColumn"/>
    from account a
    left join account_type at on at.mer_code = a.mer_code and at.type_code = a.account_type_code
    left join account_consume_scene acs on acs.account_type_code = at.type_code and acs.mer_code = AT.mer_code
    left join account_consume_scene_store_relation relation on relation.account_consume_scene_id = acs.id
    where a.mer_code= #{merCode}
    and relation.store_code in
    <foreach collection="storeCodeList" item="id" index="index" open="(" close=")" separator=",">
      #{id}
    </foreach>
  </select>

  <update id="increaseAccountSurplusQuota">
    UPDATE
    <include refid="tableName"/>
    set surplus_quota = surplus_quota + #{surplusQuota}, update_user = #{updateUser},update_time =
    now(),version = version + 1 where account_code = #{accountCode}
    and surplus_quota + #{surplusQuota} >= 0
  </update>

  <update id="updateMaxAndSurplusQuota">
    UPDATE
    <include refid="tableName"/>
    set surplus_quota = #{surplusQuota}, max_quota =#{maxQuota},update_user =
    #{updateUser},update_time = now(),version = version + 1
    where account_code = #{accountCode}

  </update>

  <update id="restoreAccountSurplusQuota">
    UPDATE
    <include refid="tableName"/>
    set surplus_quota = max_quota, update_user = #{updateUser},update_time =
    now(),version = version + 1 where account_code = #{accountCode}
    and credit = 1 and deleted = 0
  </update>

  <select id="queryByConsumeSceneIdList" resultMap="accountMap">
    select
    <include refid="baseColumn"/>
    from account a
    left join account_type at on a.account_type_code = at.type_code
    left join account_consume_scene acs on acs.account_type_code = at.type_code
    where acs.id in
    <foreach collection="list" item="id" index="index" open="(" close=")" separator=",">
      #{id}
    </foreach>
  </select>


  <select id="queryPageDTO" resultType="com.welfare.persist.dto.AccountPageDTO">
    SELECT
    a.id,
    m.mer_name as merName,
    m.mer_code as merCode,
    a.account_name AS accountName,
    a.account_code AS accountCode,
    a.account_status AS accountStatus,
    case a.account_status
    when 1 then '正常'
    when 2 then '禁用'
    end as accountStatusString,
    d.department_code AS departmentCode,
    d.department_name AS departmentName,
    at.type_name AS accountTypeName,
    a.max_quota AS maxQuota,
    a.surplus_quota AS surplusQuota,
    GROUP_CONCAT(ci.card_id) AS cardId,
    GROUP_CONCAT(
    CONCAT(
    ci.card_id,
    "(",
    CASE ci.enabled
    WHEN 0 THEN
    '禁用)'
    ELSE
    "正常)"
    END
    )
    ) AS cardIdString,
    a.account_balance AS accountBalance,
    a.binding,
    case a.binding
    when 0 then '未绑定'
    when 1 then '绑定'
    end as bindingString,
    a.phone
    FROM
    account a
    left JOIN merchant m on a.mer_code = m.mer_code
    LEFT JOIN department d ON a.store_code = d.department_code
    LEFT JOIN account_type at ON at.type_code = a.account_type_code and a.mer_code = at.mer_code
    LEFT JOIN card_info ci ON ci.account_code = a.account_code
    where a.deleted = 0
    <if test=" merCode !='' and merCode != null ">
      and a.mer_code = #{merCode} and at.mer_code = #{merCode}
    </if>
    <if test=" accountName !='' and accountName != null  ">
      and a.account_name like '%${accountName}%'
    </if>
    <if test="departmentPathList != null and departmentPathList.size() > 0">
      and
      <foreach collection="departmentPathList" item="item" index="index" open="(" close=")"
        separator="or">
        d.department_path like '${item}%'
      </foreach>
    </if>
    <if test="accountStatus != null ">
      and a.account_status = #{accountStatus}
    </if>
    <if test="binding != null ">
      and a.binding = #{binding}
    </if>
    <if test=" accountTypeCodes !='' and accountTypeCodes.size()>0">
      and at.type_code in
      <foreach collection="accountTypeCodes" item="item" open="(" close=")" separator=",">
        #{item}
      </foreach>
    </if>
    <if test=" cardId !='' and cardId != null ">
      and a. account_code in ( select a1.account_code from account a1 left join card_info ci1 on
      ci1.account_code = a1.account_code where ci1.card_id = #{cardId})
    </if>
    <if test=" phone !='' and phone != null ">
      and a.phone = #{phone}
    </if>
    GROUP BY a.account_code
    order by a.create_time desc
  </select>


  <select id="queryDetail" resultType="com.welfare.persist.dto.AccountDetailMapperDTO">
    SELECT a.id,
           a.account_name    AS accountName,
           a.account_code    AS accountCode,
           a.account_status  AS accountStatus,
           AT.type_code      AS accountTypeCode,
           AT.type_name      AS accountTypeName,
           d.department_code AS departmentCode,
           d.department_name AS departmentName,
           m.mer_code        AS merCode,
           m.mer_name        AS merName,
           a.max_quota       AS maxQuota,
           a.surplus_quota   AS surplusQuota,
           a.account_balance AS accountBalance,
           a.remark
    FROM account a
           LEFT JOIN department d ON a.store_code = d.department_code
           LEFT JOIN merchant m ON a.mer_code = m.mer_code
           LEFT JOIN account_type AT
    ON AT.type_code = a.account_type_code and a.mer_code = at.mer_code
    WHERE  a.deleted = 0
      AND a.id = #{id}
  </select>


  <select id="queryAccountBillDetail"
    resultType="com.welfare.persist.dto.AccountBillDetailMapperDTO">
    SELECT
    abd.trans_no,
    CASE abd.trans_type
    WHEN 'deposit_incr' THEN
    m.mer_name
    ELSE
    ss.store_name
    END AS storeName,
    abd.trans_type AS transType,
    CASE
    WHEN abd.trans_type = 'deposit_incr' THEN
    "入账"
    WHEN abd.trans_type = 'consume' THEN
    "出账"
    WHEN abd.trans_type = 'refund' THEN
    "入账"
    WHEN abd.trans_type = 'deposit_back' THEN
    "出账"
    END AS transTypeString,
    sum(
    DISTINCT (
    CASE
    WHEN abd.trans_type = 'deposit_incr' THEN
    abd.trans_amount
    WHEN abd.trans_type = 'consume' THEN
    abd.trans_amount * (- 1)
    WHEN abd.trans_type = 'refund' THEN
    abd.trans_amount
    WHEN abd.trans_type = 'deposit_back' THEN
    abd.trans_amount * (- 1)
    END
    )
    ) AS transAmount,
    abd.create_time AS createTime,
    (
    SELECT
    abdTemp.account_balance
    FROM
    account_bill_detail abdTemp
    WHERE
    id = (
    SELECT
    max(id)
    FROM
    account_bill_detail abd2
    WHERE
    abd2.trans_no = abd.trans_no
    )) AS accountBalance,
    GROUP_CONCAT(
    DISTINCT (mat.mer_account_type_name)
    ) AS accountTypeName
    FROM
    account_bill_detail abd
    LEFT JOIN account a ON a.account_code = abd.account_code
    LEFT JOIN merchant m ON m.mer_code = a.mer_code
    LEFT JOIN merchant_account_type mat ON m.mer_code = mat.mer_code
    LEFT JOIN account_deduction_detail addetail ON abd.trans_no = addetail.trans_no
    LEFT JOIN supplier_store ss ON addetail.store_code = ss.store_code
    WHERE
    abd.trans_type IN (
    'deposit_incr',
    'consume',
    'refund',
    'deposit_back'
    )
    AND addetail.mer_account_type = mat.mer_account_type_code  and abd.account_code = #{accountCode}
    <if test="createTimeStart != null ">
      and abd.create_time <![CDATA[>=]]> #{createTimeStart}
    </if>
    <if test="createTimeEnd != null ">
      and abd.create_time <![CDATA[<=]]> #{createTimeEnd}
    </if>
    GROUP BY
    abd.trans_no
    ORDER BY
    abd.create_time DESC
  </select>

  <select id="queryBill" resultType="com.welfare.persist.dto.AccountBillMapperDTO">
    SELECT
    abd.account_code AS accountCode,
    SUM(
    CASE

    WHEN abd.trans_type = 'deposit_incr' THEN
    trans_amount
    WHEN abd.trans_type = 'consume' THEN
    trans_amount  * ( - 1 )
    WHEN abd.trans_type = 'refund' THEN
    trans_amount
    WHEN abd.trans_type = 'deposit_back' THEN
    trans_amount * ( - 1 )
    END
    ) AS accountTotalAmount,
    COUNT( abd.id ) AS tradeNum,
    a.account_balance AS accountBalance
    FROM
    account_bill_detail abd
    LEFT JOIN account a ON a.account_code = abd.account_code
    WHERE abd.trans_type in('deposit_incr','consume','refund','deposit_back') and
    abd.account_code = #{accountCode}
    <if test="createTimeStart != null ">
      and abd.create_time <![CDATA[>=]]> #{createTimeStart}
    </if>
    <if test="createTimeEnd != null ">
      and abd.create_time <![CDATA[<=]]> #{createTimeEnd}
    </if>
  </select>

  <select id="queryIncrementDTO" resultType="com.welfare.persist.dto.AccountIncrementDTO">
    SELECT a.account_code                   AS accountCode,
           a.change_event_id                AS changeEventId,
           a.account_balance                AS accountBalance,
           GROUP_CONCAT(ci.magnetic_stripe) AS magneticStripe,
           CASE

             WHEN (
                 a.deleted = 0
                 AND AT.deleted = 0
                 AND acs.deleted = 0
                 AND a.account_status = 1
                 AND acs.`status` = 1
                 AND locate(relation.scene_consum_type, #{consumeType}) > 0
               ) THEN
               TRUE
             ELSE FALSE
             END                            AS canUse
    FROM account a
           LEFT JOIN account_type AT
    ON AT.type_code = a.account_type_code and a.mer_code = at.mer_code
      LEFT JOIN account_consume_scene acs ON acs.account_type_code = AT.type_code
      LEFT JOIN account_consume_scene_store_relation relation ON relation.account_consume_scene_id = acs.id
      LEFT JOIN card_info ci ON a.account_code = ci.account_code
    WHERE
      relation.store_code = #{storeCode}
      AND a.change_event_id
        > #{changeEventId}
    GROUP BY
      a.account_code
    ORDER BY
      a.change_event_id ASC
      LIMIT #{size}
  </select>

  <update id="batchUpdateChangeEventId" parameterType="java.util.Map">
    <foreach collection="list" item="item" index="index" open="" close="" separator=";">
      update account
      <set>
        <if test="item.changeEventId != null ">
          change_event_id=#{item.changeEventId,jdbcType=BIGINT},
        </if>
      </set>
      where account_code = #{item.accountCode,jdbcType=BIGINT}
    </foreach>
  </update>

  <select id="queryDetailByParam" resultType="com.welfare.persist.dto.AccountDetailMapperDTO">
    SELECT
    a.id,
    a.account_name AS accountName,
    a.account_code AS accountCode,
    a.account_status AS accountStatus,
    AT.type_code AS accountTypeCode,
    AT.type_name AS accountTypeName,
    d.department_code AS departmentCode,
    d.department_name AS departmentName,
    m.mer_code AS merCode,
    m.mer_name AS merName,
    a.max_quota AS maxQuota,
    a.surplus_quota AS surplusQuota,
    a.account_balance AS accountBalance,
    a.remark,
    a.phone,
    a.binding,
    a.credit,
    f.url as imgUrl
    FROM
    account a
    LEFT JOIN department d ON a.store_code = d.department_code
    LEFT JOIN merchant m ON a.mer_code = m.mer_code
    LEFT JOIN account_type AT ON AT.type_code = a.account_type_code and a.mer_code = at.mer_code
    LEFT JOIN file_universal_storage f  ON f.id =  a.file_universal_storage_id

    WHERE
    a.deleted = 0

    <if test=" id != null ">
      and a.id = #{id}
    </if>
    <if test=" accountCode != null ">
      and a.account_code = #{accountCode}
    </if>
    <if test=" phone !='' and phone != null ">
      and a.phone = #{phone}
    </if>
    <if test=" merCode !='' and merCode != null ">
      and a.mer_code = #{merCode}
    </if>
  </select>

  <select id="queryDetailPhoneAndMer" resultType="com.welfare.persist.dto.AccountDetailMapperDTO">
    SELECT a.id,
           a.account_name    AS accountName,
           a.account_code    AS accountCode,
           a.account_status  AS accountStatus,
           AT.type_code      AS accountTypeCode,
           AT.type_name      AS accountTypeName,
           d.department_code AS departmentCode,
           d.department_name AS departmentName,
           m.mer_code        AS merCode,
           m.mer_name        AS merName,
           a.max_quota       AS maxQuota,
           a.surplus_quota   AS surplusQuota,
           a.account_balance AS accountBalance,
           a.remark,
           a.phone,
           f.url as imgUrl

    FROM account a
           LEFT JOIN department d ON a.store_code = d.department_code
           LEFT JOIN merchant m ON a.mer_code = m.mer_code
           LEFT JOIN account_type AT
    ON AT.type_code = a.account_type_code and a.mer_code = at.mer_code
    			 LEFT JOIN file_universal_storage f  ON f.id =  a.file_universal_storage_id
    WHERE
      a.deleted = 0
      AND a.phone = #{phone}
      AND a.mer_code = #{merCode}
  </select>

  <select id ="countByDepartmentPath" resultType="java.lang.Integer">
    SELECT
      count(1)
    FROM
      account a
        LEFT JOIN department d ON a.store_code = d.department_code
    where
      a.mer_code = #{merCode}
      and d.department_path like '${departmentPath}%'
  </select>
</mapper>